
[≠] Diferencias entre api_requests_original.py y api_requests_tipo2.py:
--- api_requests_original.py
+++ api_requests_tipo2.py
@@ -17,17 +17,17 @@
 )
 adapter = HTTPAdapter(max_retries=retry_strategy)
 
-def get(url, params=None, headers=None):
+def fetching_data(endpoint, params=None, headers=None):
     session = requests.Session()
     session.mount("https://", adapter)
     session.mount("http://", adapter)
     try:
         if params:
             query_string = serialize_params(params)
-            url = f"{url}?{query_string}"
+            endpoint = f"{endpoint}?{query_string}"
         
-        logging.debug(f"Sending GET request to {url} with headers {headers}")
-        response = session.get(url, headers=headers)
+        logging.debug(f"Sending GET request to {endpoint} with headers {headers}")
+        response = session.get(endpoint, headers=headers)
         response.raise_for_status()
         logging.debug(f"Response received: {response.status_code} - {response.content[:100]}")
         return response
@@ -35,23 +35,23 @@
         logging.error(f"Request failed: {e}")
         return None
 
-def post(url, data=None, headers=None):
-    response = requests.post(url, json=data, headers=headers)
+def sending_post_request(endpoint, data=None, headers=None):
+    response = requests.post(endpoint, json=data, headers=headers)
     return response
 
-def put(url, data=None, headers=None):
-    response = requests.put(url, json=data, headers=headers)
+def sending_put_request(endpoint, data=None, headers=None):
+    response = requests.put(endpoint, json=data, headers=headers)
     return response
 
-def delete(url, headers=None):
-    response = requests.delete(url, headers=headers)
+def sending_delete_request(endpoint, headers=None):
+    response = requests.delete(endpoint, headers=headers)
     return response
 
-def get_with_path_params(base_url, path_params, headers=None):
+def getting_with_path_params(base_endpoint, path_params, headers=None):
     try:
-        url = construct_url(base_url, path_params)
-        logging.debug(f"Sending GET request to {url} with headers {headers}")
-        response = requests.get(url, headers=headers)
+        endpoint = construct_url(base_endpoint, path_params)
+        logging.debug(f"Sending GET request to {endpoint} with headers {headers}")
+        response = requests.get(endpoint, headers=headers)
         response.raise_for_status()
         logging.debug(f"Response received: {response.status_code} - {response.content[:100]}")
         return response


[≠] Diferencias entre api_requests_original.py y api_requests_tipo3.py:
--- api_requests_original.py
+++ api_requests_tipo3.py
@@ -5,25 +5,23 @@
 from query_params import serialize_params
 from path_params import construct_url
 
-# Configure logging
 logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
 
-# Setup retry strategy
 retry_strategy = Retry(
-    total=3,  # Total number of retries
-    status_forcelist=[429, 500, 502, 503, 504],  # Status codes to retry
+    total=3,
+    status_forcelist=[429, 500, 502, 503, 504],
     allowed_methods=["HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE", "POST"],
-    backoff_factor=1  # Backoff factor to apply between attempts
+    backoff_factor=1
 )
 adapter = HTTPAdapter(max_retries=retry_strategy)
 
-def get(url, params=None, headers=None):
+def obtain(url, information=None, headers=None):
     session = requests.Session()
     session.mount("https://", adapter)
     session.mount("http://", adapter)
     try:
-        if params:
-            query_string = serialize_params(params)
+        if information:
+            query_string = serialize_params(information)
             url = f"{url}?{query_string}"
         
         logging.debug(f"Sending GET request to {url} with headers {headers}")
@@ -35,21 +33,21 @@
         logging.error(f"Request failed: {e}")
         return None
 
-def post(url, data=None, headers=None):
+def post_action(url, data=None, headers=None):
     response = requests.post(url, json=data, headers=headers)
     return response
 
-def put(url, data=None, headers=None):
+def add(url, data=None, headers=None):
     response = requests.put(url, json=data, headers=headers)
     return response
 
-def delete(url, headers=None):
+def delete_action(url, headers=None):
     response = requests.delete(url, headers=headers)
     return response
 
-def get_with_path_params(base_url, path_params, headers=None):
+def obtain_with_path_information(base_url, path_information, headers=None):
     try:
-        url = construct_url(base_url, path_params)
+        url = construct_url(base_url, path_information)
         logging.debug(f"Sending GET request to {url} with headers {headers}")
         response = requests.get(url, headers=headers)
         response.raise_for_status()


[≠] Diferencias entre path_params_original.py y path_params_tipo2.py:
--- path_params_original.py
+++ path_params_tipo2.py
@@ -1,16 +1,16 @@
-from urllib.parse import quote
+from urllib.parse import quote as q
 
-def construct_url(base_url, path_params):
+def generate_link(base_link, path_data):
     """
-    Construct a URL by appending path parameters to a base URL.
-    Path parameters are URL-encoded to handle special characters.
+    Generate a link by appending path data to a base link.
+    Path data is URL-encoded to handle special characters.
 
     Args:
-        base_url (str): The base URL to which path parameters will be appended.
-        path_params (list or tuple): A sequence of path parameters to append to the URL.
+        base_link (str): The base link to which path data will be appended.
+        path_data (list or tuple): A sequence of path data to append to the link.
 
     Returns:
-        str: The fully constructed URL.
+        str: The fully generated link.
     """
-    encoded_params = [quote(str(param)) for param in path_params]
-    return f"{base_url}/{'/'.join(encoded_params)}" 
+    encoded_data = [q(str(data)) for data in path_data]
+    return f"{base_link}/{'/'.join(encoded_data)}"


[≠] Diferencias entre path_params_original.py y path_params_tipo3.py:
--- path_params_original.py
+++ path_params_tipo3.py
@@ -1,16 +1,5 @@
 from urllib.parse import quote
 
-def construct_url(base_url, path_params):
-    """
-    Construct a URL by appending path parameters to a base URL.
-    Path parameters are URL-encoded to handle special characters.
-
-    Args:
-        base_url (str): The base URL to which path parameters will be appended.
-        path_params (list or tuple): A sequence of path parameters to append to the URL.
-
-    Returns:
-        str: The fully constructed URL.
-    """
-    encoded_params = [quote(str(param)) for param in path_params]
-    return f"{base_url}/{'/'.join(encoded_params)}" 
+def build_url(base_url, path_args):
+    encoded_args = [quote(str(arg)) for arg in path_args]
+    return f"{base_url}/{'/'.join(encoded_args)}"


[≠] Diferencias entre query_params_original.py y query_params_tipo2.py:
--- query_params_original.py
+++ query_params_tipo2.py
@@ -1,21 +1,21 @@
 from urllib.parse import urlencode
 
-def serialize_params(params):
+def transform_params(parameters):
     """
-    Serialize complex query parameters into a URL-encoded string.
-    Handles lists, dictionaries, and nested combinations.
+    Transform convoluted query parameters into a URL-encoded string.
+    Handles arrays, dictionaries, and nested amalgamations.
 
     Args:
-        params (dict): The dictionary of parameters to serialize.
+        parameters (dict): The dictionary of parameters to transform.
 
     Returns:
         str: URL-encoded query parameters.
     """
     # Recursively encode parameters
-    def encode_dict(data):
+    def transform_dict(data):
         for key, value in data.items():
             if isinstance(value, dict):
-                for subkey, subvalue in encode_dict(value).items():
+                for subkey, subvalue in transform_dict(value).items():
                     yield f"{key}[{subkey}]", subvalue
             elif isinstance(value, list):
                 for subvalue in value:
@@ -23,5 +23,5 @@
             else:
                 yield key, value
 
-    encoded_params = dict(encode_dict(params))
-    return urlencode(encoded_params, doseq=True) 
+    transformed_params = dict(transform_dict(parameters))
+    return urlencode(transformed_params, doseq=True)


[≠] Diferencias entre query_params_original.py y query_params_tipo3.py:
--- query_params_original.py
+++ query_params_tipo3.py
@@ -1,21 +1,21 @@
 from urllib.parse import urlencode
 
-def serialize_params(params):
+def codify_data(data):
     """
-    Serialize complex query parameters into a URL-encoded string.
+    Codify intricate query data into a URL-encoded string.
     Handles lists, dictionaries, and nested combinations.
 
     Args:
-        params (dict): The dictionary of parameters to serialize.
+        data (dict): The dictionary of data to codify.
 
     Returns:
-        str: URL-encoded query parameters.
+        str: URL-encoded query data.
     """
-    # Recursively encode parameters
-    def encode_dict(data):
+    # Recursively encode data
+    def encode_dictionary(data):
         for key, value in data.items():
             if isinstance(value, dict):
-                for subkey, subvalue in encode_dict(value).items():
+                for subkey, subvalue in encode_dictionary(value).items():
                     yield f"{key}[{subkey}]", subvalue
             elif isinstance(value, list):
                 for subvalue in value:
@@ -23,5 +23,5 @@
             else:
                 yield key, value
 
-    encoded_params = dict(encode_dict(params))
-    return urlencode(encoded_params, doseq=True) 
+    encoded_data = dict(encode_dictionary(data))
+    return urlencode(encoded_data, doseq=True)


[≠] Diferencias entre response_handling_original.py y response_handling_tipo2.py:
--- response_handling_original.py
+++ response_handling_tipo2.py
@@ -1,18 +1,18 @@
-import zipfile
-import os
-import logging
+import zipping
+import operating_sys
+import loggy
 
-def handle_response(response, save_path):
+def process_server_response(resp, storage_path):
     try:
-        content_type = response.headers.get('Content-Type', '')
-        if 'application/zip' in content_type:
-            with open('temp.zip', 'wb') as f:
-                f.write(response.content)
-            with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
-                zip_ref.extractall(save_path)
-            os.remove('temp.zip')
-            logging.info("Zip file processed and extracted.")
+        cont_type = resp.headers.get('Content-Type', '')
+        if 'application/zip' in cont_type:
+            with open('temp.zip', 'wb') as fl:
+                fl.write(resp.content)
+            with zipping.ZipFile('temp.zip', 'r') as zp_ref:
+                zp_ref.extractall(storage_path)
+            operating_sys.remove('temp.zip')
+            loggy.info("Zip file managed and extracted.")
         else:
-            logging.info("Response content type: {content_type} - no special handling applied.")
-    except Exception as e:
-        logging.error(f"Failed to handle response: {e}")
+            loggy.info(f"Response content type: {cont_type} - no special dealing done.")
+    except Exception as exc:
+        loggy.error(f"Failed to process response: {exc}")


[≠] Diferencias entre response_handling_original.py y response_handling_tipo3.py:
--- response_handling_original.py
+++ response_handling_tipo3.py
@@ -2,17 +2,17 @@
 import os
 import logging
 
-def handle_response(response, save_path):
+def procesar_respuesta(respuesta, ruta_guardado):
     try:
-        content_type = response.headers.get('Content-Type', '')
-        if 'application/zip' in content_type:
-            with open('temp.zip', 'wb') as f:
-                f.write(response.content)
-            with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
-                zip_ref.extractall(save_path)
-            os.remove('temp.zip')
-            logging.info("Zip file processed and extracted.")
+        tipo_contenido = respuesta.headers.get('Content-Type', '')
+        if 'application/zip' in tipo_contenido:
+            with open('temporal.zip', 'wb') as archivo:
+                archivo.write(respuesta.content)
+            with zipfile.ZipFile('temporal.zip', 'r') as zip_ref:
+                zip_ref.extractall(ruta_guardado)
+            os.remove('temporal.zip')
+            logging.info("Archivo ZIP procesado y extraído.")
         else:
-            logging.info("Response content type: {content_type} - no special handling applied.")
+            logging.info(f"Tipo de contenido de la respuesta: {tipo_contenido} - no se aplicó manejo especial.")
     except Exception as e:
-        logging.error(f"Failed to handle response: {e}")
+        logging.error(f"No se pudo procesar la respuesta: {e}")


[≠] Diferencias entre test_all_original.py y test_all_tipo2.py:
--- test_all_original.py
+++ test_all_tipo2.py
@@ -1,108 +1,108 @@
 import unittest
 from unittest.mock import patch, MagicMock
 from requests.exceptions import RequestException
-from api_requests import get, post, put, delete, get_with_path_params
-from query_params import serialize_params
-from path_params import construct_url
-from response_handling import handle_response
+from api_requests import fetch, deliver, transfer, erase, fetch_with_data
+from query_params import serialize_parameters
+from path_params import assemble_link
+from response_handling import process_response
 
-class TestAPIRequests(unittest.TestCase):
+class SuperTest(unittest.TestCase):
 
     @patch('requests.Session.get')
-    def test_get_success(self, mock_get):
+    def test_fetch_success(self, mock_get):
         mock_response = MagicMock()
         mock_response.status_code = 200
-        mock_response.content = b'{"key": "value"}'
+        mock_response.content = b'{"code": "secret"}'
         mock_get.return_value = mock_response
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.Session.get')
-    def test_get_failure(self, mock_get):
+    def test_fetch_failure(self, mock_get):
         mock_get.side_effect = RequestException("Connection Error")
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNone(response)
 
     @patch('requests.post')
-    def test_post(self, mock_post):
+    def test_deliver(self, mock_post):
         mock_response = MagicMock()
         mock_response.status_code = 201
         mock_post.return_value = mock_response
 
-        response = post("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
+        response = deliver("https://jsonplaceholder.typicode.com/posts", data={"code": "secret"})
         self.assertEqual(response.status_code, 201)
 
     @patch('requests.put')
-    def test_put(self, mock_put):
+    def test_transfer(self, mock_put):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_put.return_value = mock_response
 
-        response = put("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
+        response = transfer("https://jsonplaceholder.typicode.com/posts/1", data={"code": "secret"})
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.delete')
-    def test_delete(self, mock_delete):
+    def test_erase(self, mock_delete):
         mock_response = MagicMock()
         mock_response.status_code = 204
         mock_delete.return_value = mock_response
 
-        response = delete("https://jsonplaceholder.typicode.com/posts/1")
+        response = erase("https://jsonplaceholder.typicode.com/posts/1")
         self.assertEqual(response.status_code, 204)
 
     @patch('requests.get')
-    def test_get_with_path_params(self, mock_get):
+    def test_fetch_with_data(self, mock_get):
         mock_response = MagicMock()
         mock_response.status_code = 200
-        mock_response.content = b'{"key": "value"}'
+        mock_response.content = b'{"code": "secret"}'
         mock_get.return_value = mock_response
 
-        response = get_with_path_params("https://jsonplaceholder.typicode.com/posts", ["1"])
+        response = fetch_with_data("https://jsonplaceholder.typicode.com/posts", ["1"])
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
-class TestQueryParams(unittest.TestCase):
+class TestQParams(unittest.TestCase):
 
-    def test_serialize_params(self):
+    def test_serialize_parameters(self):
         params = {
-            "key1": "value1",
-            "key2": "value2",
-            "key3": "value3"
+            "token1": "auth1",
+            "token2": "auth2",
+            "token3": "auth3"
         }
-        result = serialize_params(params)
-        expected = "key1=value1&key2=value2&key3=value3"
+        result = serialize_parameters(params)
+        expected = "token1=auth1&token2=auth2&token3=auth3"
         self.assertEqual(result, expected)
 
-class TestPathParams(unittest.TestCase):
+class TestPParams(unittest.TestCase):
 
-    def test_construct_url(self):
+    def test_assemble_link(self):
         base_url = "https://jsonplaceholder.typicode.com"
         path_params = ["posts", "1"]
-        result = construct_url(base_url, path_params)
+        result = assemble_link(base_url, path_params)
         expected = "https://jsonplaceholder.typicode.com/posts/1"
         self.assertEqual(result, expected)
 
-class TestResponseHandling(unittest.TestCase):
+class TestRHandling(unittest.TestCase):
 
     @patch('builtins.open', new_callable=unittest.mock.mock_open)
-    def test_handle_response_zip(self, mock_open):
+    def test_process_response_zip(self, mock_open):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/zip'}
         mock_response.content = b'PK\x03\x04'  # Mock zip file content
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_open.assert_called_once_with('temp.zip', 'wb')
 
     @patch('logging.info')
-    def test_handle_response_non_zip(self, mock_logging_info):
+    def test_process_response_non_zip(self, mock_logging_info):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/json'}
-        mock_response.content = b'{"key": "value"}'
+        mock_response.content = b'{"code": "secret"}'
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_logging_info.assert_called_with("Response content type: {content_type} - no special handling applied.")
 
 if __name__ == "__main__":


[≠] Diferencias entre test_all_original.py y test_all_tipo3.py:
--- test_all_original.py
+++ test_all_tipo3.py
@@ -1,108 +1,108 @@
 import unittest
 from unittest.mock import patch, MagicMock
 from requests.exceptions import RequestException
-from api_requests import get, post, put, delete, get_with_path_params
-from query_params import serialize_params
-from path_params import construct_url
-from response_handling import handle_response
+from api_requests import fetch, submit, update, remove, fetch_with_parameters
+from query_params import format_params
+from path_params import build_url
+from response_handling import process_response
 
 class TestAPIRequests(unittest.TestCase):
 
     @patch('requests.Session.get')
-    def test_get_success(self, mock_get):
+    def test_fetch_success(self, mock_get):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_response.content = b'{"key": "value"}'
         mock_get.return_value = mock_response
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.Session.get')
-    def test_get_failure(self, mock_get):
+    def test_fetch_failure(self, mock_get):
         mock_get.side_effect = RequestException("Connection Error")
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNone(response)
 
     @patch('requests.post')
-    def test_post(self, mock_post):
+    def test_submit(self, mock_post):
         mock_response = MagicMock()
         mock_response.status_code = 201
         mock_post.return_value = mock_response
 
-        response = post("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
+        response = submit("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
         self.assertEqual(response.status_code, 201)
 
     @patch('requests.put')
-    def test_put(self, mock_put):
+    def test_update(self, mock_put):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_put.return_value = mock_response
 
-        response = put("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
+        response = update("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.delete')
-    def test_delete(self, mock_delete):
+    def test_remove(self, mock_delete):
         mock_response = MagicMock()
         mock_response.status_code = 204
         mock_delete.return_value = mock_response
 
-        response = delete("https://jsonplaceholder.typicode.com/posts/1")
+        response = remove("https://jsonplaceholder.typicode.com/posts/1")
         self.assertEqual(response.status_code, 204)
 
     @patch('requests.get')
-    def test_get_with_path_params(self, mock_get):
+    def test_fetch_with_parameters(self, mock_get):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_response.content = b'{"key": "value"}'
         mock_get.return_value = mock_response
 
-        response = get_with_path_params("https://jsonplaceholder.typicode.com/posts", ["1"])
+        response = fetch_with_parameters("https://jsonplaceholder.typicode.com/posts", ["1"])
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
 class TestQueryParams(unittest.TestCase):
 
-    def test_serialize_params(self):
+    def test_format_params(self):
         params = {
             "key1": "value1",
             "key2": "value2",
             "key3": "value3"
         }
-        result = serialize_params(params)
+        result = format_params(params)
         expected = "key1=value1&key2=value2&key3=value3"
         self.assertEqual(result, expected)
 
 class TestPathParams(unittest.TestCase):
 
-    def test_construct_url(self):
+    def test_build_url(self):
         base_url = "https://jsonplaceholder.typicode.com"
         path_params = ["posts", "1"]
-        result = construct_url(base_url, path_params)
+        result = build_url(base_url, path_params)
         expected = "https://jsonplaceholder.typicode.com/posts/1"
         self.assertEqual(result, expected)
 
 class TestResponseHandling(unittest.TestCase):
 
     @patch('builtins.open', new_callable=unittest.mock.mock_open)
-    def test_handle_response_zip(self, mock_open):
+    def test_process_response_zip(self, mock_open):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/zip'}
         mock_response.content = b'PK\x03\x04'  # Mock zip file content
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_open.assert_called_once_with('temp.zip', 'wb')
 
     @patch('logging.info')
-    def test_handle_response_non_zip(self, mock_logging_info):
+    def test_process_response_non_zip(self, mock_logging_info):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/json'}
         mock_response.content = b'{"key": "value"}'
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_logging_info.assert_called_with("Response content type: {content_type} - no special handling applied.")
 
 if __name__ == "__main__":


[≠] Diferencias entre __init___original.py y __init___tipo2.py:
--- __init___original.py
+++ __init___tipo2.py
@@ -1,10 +1,10 @@
-from .api_requests import get, post, put, delete, get_with_path_params
-from .query_params import serialize_params
-from .path_params import construct_url
-from .response_handling import handle_response
+from .serv_requests import fetch, deliver, submit, remove, fetch_with_route_params
+from .params_query import encode_params
+from .route_params import build_path
+from .response_management import process_response
 
 __all__ = [
-    "get", "post", "put", "delete", "get_with_path_params",
-    "serialize_params", "construct_url",
-    "handle_response"
-]
+    "fetch", "deliver", "submit", "remove", "fetch_with_route_params",
+    "encode_params", "build_path",
+    "process_response"
+]


[≠] Diferencias entre __init___original.py y __init___tipo3.py:
--- __init___original.py
+++ __init___tipo3.py
@@ -1,10 +1,10 @@
-from .api_requests import get, post, put, delete, get_with_path_params
-from .query_params import serialize_params
-from .path_params import construct_url
-from .response_handling import handle_response
+from .api_requests import obtener, enviar, poner, eliminar, obtener_con_parametros_de_ruta
+from .query_params import serializar_parametros
+from .path_params import construir_url
+from .response_handling import manejar_respuesta
 
 __all__ = [
-    "get", "post", "put", "delete", "get_with_path_params",
-    "serialize_params", "construct_url",
-    "handle_response"
-]
+    "obtener", "enviar", "poner", "eliminar", "obtener_con_parametros_de_ruta",
+    "serializar_parametros", "construir_url",
+    "manejar_respuesta"
+]


[≠] Diferencias entre api_requests_original.py y api_requests_tipo2.py:
--- api_requests_original.py
+++ api_requests_tipo2.py
@@ -17,7 +17,7 @@
 )
 adapter = HTTPAdapter(max_retries=retry_strategy)
 
-def get(url, params=None, headers=None):
+def perform_query(url, params=None, headers=None):
     session = requests.Session()
     session.mount("https://", adapter)
     session.mount("http://", adapter)
@@ -35,21 +35,21 @@
         logging.error(f"Request failed: {e}")
         return None
 
-def post(url, data=None, headers=None):
+def create_resource(url, data=None, headers=None):
     response = requests.post(url, json=data, headers=headers)
     return response
 
-def put(url, data=None, headers=None):
+def modify_resource(url, data=None, headers=None):
     response = requests.put(url, json=data, headers=headers)
     return response
 
-def delete(url, headers=None):
+def remove_resource(url, headers=None):
     response = requests.delete(url, headers=headers)
     return response
 
-def get_with_path_params(base_url, path_params, headers=None):
+def get_with_custom_params(base_url, custom_params, headers=None):
     try:
-        url = construct_url(base_url, path_params)
+        url = construct_url(base_url, custom_params)
         logging.debug(f"Sending GET request to {url} with headers {headers}")
         response = requests.get(url, headers=headers)
         response.raise_for_status()


[≠] Diferencias entre api_requests_original.py y api_requests_tipo3.py:
--- api_requests_original.py
+++ api_requests_tipo3.py
@@ -5,19 +5,17 @@
 from query_params import serialize_params
 from path_params import construct_url
 
-# Configure logging
 logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
 
-# Setup retry strategy
 retry_strategy = Retry(
-    total=3,  # Total number of retries
-    status_forcelist=[429, 500, 502, 503, 504],  # Status codes to retry
+    total=3,
+    status_forcelist=[429, 500, 502, 503, 504],
     allowed_methods=["HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE", "POST"],
-    backoff_factor=1  # Backoff factor to apply between attempts
+    backoff_factor=1
 )
 adapter = HTTPAdapter(max_retries=retry_strategy)
 
-def get(url, params=None, headers=None):
+def request_get(url, params=None, headers=None):
     session = requests.Session()
     session.mount("https://", adapter)
     session.mount("http://", adapter)
@@ -35,19 +33,19 @@
         logging.error(f"Request failed: {e}")
         return None
 
-def post(url, data=None, headers=None):
+def request_post(url, data=None, headers=None):
     response = requests.post(url, json=data, headers=headers)
     return response
 
-def put(url, data=None, headers=None):
+def request_put(url, data=None, headers=None):
     response = requests.put(url, json=data, headers=headers)
     return response
 
-def delete(url, headers=None):
+def request_delete(url, headers=None):
     response = requests.delete(url, headers=headers)
     return response
 
-def get_with_path_params(base_url, path_params, headers=None):
+def request_get_with_path_params(base_url, path_params, headers=None):
     try:
         url = construct_url(base_url, path_params)
         logging.debug(f"Sending GET request to {url} with headers {headers}")


[≠] Diferencias entre path_params_original.py y path_params_tipo2.py:
--- path_params_original.py
+++ path_params_tipo2.py
@@ -1,16 +1,16 @@
-from urllib.parse import quote
+from urllib.parse import quote as q
 
-def construct_url(base_url, path_params):
+def create_hyperlink(base_hyperlink, path_elements):
     """
-    Construct a URL by appending path parameters to a base URL.
-    Path parameters are URL-encoded to handle special characters.
+    Construct a hyperlink by concatenating path elements to a base hyperlink.
+    Path elements are URL-encoded to handle special characters.
 
     Args:
-        base_url (str): The base URL to which path parameters will be appended.
-        path_params (list or tuple): A sequence of path parameters to append to the URL.
+        base_hyperlink (str): The base hyperlink to which path elements will be concatenated.
+        path_elements (list or tuple): A sequence of path elements to concatenate to the hyperlink.
 
     Returns:
-        str: The fully constructed URL.
+        str: The fully constructed hyperlink.
     """
-    encoded_params = [quote(str(param)) for param in path_params]
-    return f"{base_url}/{'/'.join(encoded_params)}" 
+    encoded_elements = [q(str(element)) for element in path_elements]
+    return f"{base_hyperlink}/{'/'.join(encoded_elements)}" 


[≠] Diferencias entre path_params_original.py y path_params_tipo3.py:
--- path_params_original.py
+++ path_params_tipo3.py
@@ -1,16 +1,5 @@
 from urllib.parse import quote
 
-def construct_url(base_url, path_params):
-    """
-    Construct a URL by appending path parameters to a base URL.
-    Path parameters are URL-encoded to handle special characters.
-
-    Args:
-        base_url (str): The base URL to which path parameters will be appended.
-        path_params (list or tuple): A sequence of path parameters to append to the URL.
-
-    Returns:
-        str: The fully constructed URL.
-    """
-    encoded_params = [quote(str(param)) for param in path_params]
-    return f"{base_url}/{'/'.join(encoded_params)}" 
+def build_url(base_url, path_parameters):
+    encoded_parameters = [quote(str(param)) for param in path_parameters]
+    return f"{base_url}/{'/'.join(encoded_parameters)}" 


[≠] Diferencias entre query_params_original.py y query_params_tipo2.py:
--- query_params_original.py
+++ query_params_tipo2.py
@@ -1,21 +1,21 @@
 from urllib.parse import urlencode
 
-def serialize_params(params):
+def obfuscate_parameters(parameters):
     """
     Serialize complex query parameters into a URL-encoded string.
     Handles lists, dictionaries, and nested combinations.
 
     Args:
-        params (dict): The dictionary of parameters to serialize.
+        parameters (dict): The dictionary of parameters to serialize.
 
     Returns:
         str: URL-encoded query parameters.
     """
     # Recursively encode parameters
-    def encode_dict(data):
+    def scramble_dict(data):
         for key, value in data.items():
             if isinstance(value, dict):
-                for subkey, subvalue in encode_dict(value).items():
+                for subkey, subvalue in scramble_dict(value).items():
                     yield f"{key}[{subkey}]", subvalue
             elif isinstance(value, list):
                 for subvalue in value:
@@ -23,5 +23,5 @@
             else:
                 yield key, value
 
-    encoded_params = dict(encode_dict(params))
-    return urlencode(encoded_params, doseq=True) 
+    encoded_parameters = dict(scramble_dict(parameters))
+    return urlencode(encoded_parameters, doseq=True)


[≠] Diferencias entre query_params_original.py y query_params_tipo3.py:
--- query_params_original.py
+++ query_params_tipo3.py
@@ -1,21 +1,10 @@
 from urllib.parse import urlencode
 
-def serialize_params(params):
-    """
-    Serialize complex query parameters into a URL-encoded string.
-    Handles lists, dictionaries, and nested combinations.
-
-    Args:
-        params (dict): The dictionary of parameters to serialize.
-
-    Returns:
-        str: URL-encoded query parameters.
-    """
-    # Recursively encode parameters
-    def encode_dict(data):
+def codify_params(data):
+    def encode_dictionary(data):
         for key, value in data.items():
             if isinstance(value, dict):
-                for subkey, subvalue in encode_dict(value).items():
+                for subkey, subvalue in encode_dictionary(value).items():
                     yield f"{key}[{subkey}]", subvalue
             elif isinstance(value, list):
                 for subvalue in value:
@@ -23,5 +12,5 @@
             else:
                 yield key, value
 
-    encoded_params = dict(encode_dict(params))
-    return urlencode(encoded_params, doseq=True) 
+    encoded_parameters = dict(encode_dictionary(data))
+    return urlencode(encoded_parameters, doseq=True)


[≠] Diferencias entre response_handling_original.py y response_handling_tipo2.py:
--- response_handling_original.py
+++ response_handling_tipo2.py
@@ -2,17 +2,17 @@
 import os
 import logging
 
-def handle_response(response, save_path):
+def process_data(data, storage_location):
     try:
-        content_type = response.headers.get('Content-Type', '')
-        if 'application/zip' in content_type:
-            with open('temp.zip', 'wb') as f:
-                f.write(response.content)
-            with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
-                zip_ref.extractall(save_path)
+        data_type = data.headers.get('Data-Type', '')
+        if 'application/zip' in data_type:
+            with open('temp.zip', 'wb') as d:
+                d.write(data.content)
+            with zipfile.ZipFile('temp.zip', 'r') as zip_data:
+                zip_data.extractall(storage_location)
             os.remove('temp.zip')
-            logging.info("Zip file processed and extracted.")
+            logging.info("Zip data processed and extracted.")
         else:
-            logging.info("Response content type: {content_type} - no special handling applied.")
-    except Exception as e:
-        logging.error(f"Failed to handle response: {e}")
+            logging.info("Response data type: {data_type} - no unique handling applied.")
+    except Exception as error:
+        logging.error(f"Failed to process data: {error}")


[≠] Diferencias entre response_handling_original.py y response_handling_tipo3.py:
--- response_handling_original.py
+++ response_handling_tipo3.py
@@ -2,17 +2,17 @@
 import os
 import logging
 
-def handle_response(response, save_path):
+def process_response(resp, path_to_save):
     try:
-        content_type = response.headers.get('Content-Type', '')
+        content_type = resp.headers.get('Content-Type', '')
         if 'application/zip' in content_type:
-            with open('temp.zip', 'wb') as f:
-                f.write(response.content)
-            with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
-                zip_ref.extractall(save_path)
+            with open('temp.zip', 'wb') as file:
+                file.write(resp.content)
+            with zipfile.ZipFile('temp.zip', 'r') as zip_file:
+                zip_file.extractall(path_to_save)
             os.remove('temp.zip')
             logging.info("Zip file processed and extracted.")
         else:
-            logging.info("Response content type: {content_type} - no special handling applied.")
-    except Exception as e:
-        logging.error(f"Failed to handle response: {e}")
+            logging.info(f"Response content type: {content_type} - no special handling applied.")
+    except Exception as ex:
+        logging.error(f"Failed to process response: {ex}")


[≠] Diferencias entre test_all_original.py y test_all_tipo2.py:
--- test_all_original.py
+++ test_all_tipo2.py
@@ -1,108 +1,108 @@
 import unittest
 from unittest.mock import patch, MagicMock
 from requests.exceptions import RequestException
-from api_requests import get, post, put, delete, get_with_path_params
-from query_params import serialize_params
-from path_params import construct_url
-from response_handling import handle_response
+from api_requests import fetch_data, transmit_data, update_data, erase_data, fetch_with_path
+from query_params import encode_params
+from path_params import build_url
+from response_handling import process_response
 
-class TestAPIRequests(unittest.TestCase):
+class TestConnection(unittest.TestCase):
 
     @patch('requests.Session.get')
-    def test_get_success(self, mock_get):
+    def test_fetch_data_success(self, mock_fetch):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_response.content = b'{"key": "value"}'
-        mock_get.return_value = mock_response
+        mock_fetch.return_value = mock_response
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch_data("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.Session.get')
-    def test_get_failure(self, mock_get):
-        mock_get.side_effect = RequestException("Connection Error")
+    def test_fetch_data_failure(self, mock_fetch):
+        mock_fetch.side_effect = RequestException("Connection Error")
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
+        response = fetch_data("https://jsonplaceholder.typicode.com/posts/1")
         self.assertIsNone(response)
 
     @patch('requests.post')
-    def test_post(self, mock_post):
+    def test_transmit_data(self, mock_transmit):
         mock_response = MagicMock()
         mock_response.status_code = 201
-        mock_post.return_value = mock_response
+        mock_transmit.return_value = mock_response
 
-        response = post("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
+        response = transmit_data("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
         self.assertEqual(response.status_code, 201)
 
     @patch('requests.put')
-    def test_put(self, mock_put):
+    def test_update_data(self, mock_update):
         mock_response = MagicMock()
         mock_response.status_code = 200
-        mock_put.return_value = mock_response
+        mock_update.return_value = mock_response
 
-        response = put("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
+        response = update_data("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
         self.assertEqual(response.status_code, 200)
 
     @patch('requests.delete')
-    def test_delete(self, mock_delete):
+    def test_erase_data(self, mock_erase):
         mock_response = MagicMock()
         mock_response.status_code = 204
-        mock_delete.return_value = mock_response
+        mock_erase.return_value = mock_response
 
-        response = delete("https://jsonplaceholder.typicode.com/posts/1")
+        response = erase_data("https://jsonplaceholder.typicode.com/posts/1")
         self.assertEqual(response.status_code, 204)
 
     @patch('requests.get')
-    def test_get_with_path_params(self, mock_get):
+    def test_fetch_with_path(self, mock_fetch):
         mock_response = MagicMock()
         mock_response.status_code = 200
         mock_response.content = b'{"key": "value"}'
-        mock_get.return_value = mock_response
+        mock_fetch.return_value = mock_response
 
-        response = get_with_path_params("https://jsonplaceholder.typicode.com/posts", ["1"])
+        response = fetch_with_path("https://jsonplaceholder.typicode.com/posts", ["1"])
         self.assertIsNotNone(response)
         self.assertEqual(response.status_code, 200)
 
-class TestQueryParams(unittest.TestCase):
+class TestFilters(unittest.TestCase):
 
-    def test_serialize_params(self):
+    def test_encode_params(self):
         params = {
             "key1": "value1",
             "key2": "value2",
             "key3": "value3"
         }
-        result = serialize_params(params)
+        result = encode_params(params)
         expected = "key1=value1&key2=value2&key3=value3"
         self.assertEqual(result, expected)
 
-class TestPathParams(unittest.TestCase):
+class TestPaths(unittest.TestCase):
 
-    def test_construct_url(self):
+    def test_build_url(self):
         base_url = "https://jsonplaceholder.typicode.com"
         path_params = ["posts", "1"]
-        result = construct_url(base_url, path_params)
+        result = build_url(base_url, path_params)
         expected = "https://jsonplaceholder.typicode.com/posts/1"
         self.assertEqual(result, expected)
 
-class TestResponseHandling(unittest.TestCase):
+class TestResponses(unittest.TestCase):
 
     @patch('builtins.open', new_callable=unittest.mock.mock_open)
-    def test_handle_response_zip(self, mock_open):
+    def test_process_response_zip(self, mock_open):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/zip'}
         mock_response.content = b'PK\x03\x04'  # Mock zip file content
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_open.assert_called_once_with('temp.zip', 'wb')
 
     @patch('logging.info')
-    def test_handle_response_non_zip(self, mock_logging_info):
+    def test_process_response_non_zip(self, mock_logging_info):
         mock_response = MagicMock()
         mock_response.headers = {'Content-Type': 'application/json'}
         mock_response.content = b'{"key": "value"}'
 
-        handle_response(mock_response, "/fake/path")
+        process_response(mock_response, "/fake/path")
         mock_logging_info.assert_called_with("Response content type: {content_type} - no special handling applied.")
 
 if __name__ == "__main__":


[≠] Diferencias entre test_all_original.py y test_all_tipo3.py:
--- test_all_original.py
+++ test_all_tipo3.py
@@ -1,109 +1,109 @@
 import unittest
 from unittest.mock import patch, MagicMock
 from requests.exceptions import RequestException
-from api_requests import get, post, put, delete, get_with_path_params
-from query_params import serialize_params
-from path_params import construct_url
-from response_handling import handle_response
+from api_requests import obtener, publicar, poner, eliminar, obtener_con_parametros_de_ruta
+from query_params import serializar_parametros
+from path_params import construir_url
+from response_handling import manejar_respuesta
 
 class TestAPIRequests(unittest.TestCase):
 
     @patch('requests.Session.get')
-    def test_get_success(self, mock_get):
-        mock_response = MagicMock()
-        mock_response.status_code = 200
-        mock_response.content = b'{"key": "value"}'
-        mock_get.return_value = mock_response
+    def test_obtener_exito(self, mock_obtener):
+        mock_respuesta = MagicMock()
+        mock_respuesta.status_code = 200
+        mock_respuesta.content = b'{"key": "value"}'
+        mock_obtener.return_value = mock_respuesta
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
-        self.assertIsNotNone(response)
-        self.assertEqual(response.status_code, 200)
+        respuesta = obtener("https://jsonplaceholder.typicode.com/posts/1")
+        self.assertIsNotNone(respuesta)
+        self.assertEqual(respuesta.status_code, 200)
 
     @patch('requests.Session.get')
-    def test_get_failure(self, mock_get):
-        mock_get.side_effect = RequestException("Connection Error")
+    def test_obtener_fallo(self, mock_obtener):
+        mock_obtener.side_effect = RequestException("Error de conexión")
 
-        response = get("https://jsonplaceholder.typicode.com/posts/1")
-        self.assertIsNone(response)
+        respuesta = obtener("https://jsonplaceholder.typicode.com/posts/1")
+        self.assertIsNone(respuesta)
 
     @patch('requests.post')
-    def test_post(self, mock_post):
-        mock_response = MagicMock()
-        mock_response.status_code = 201
-        mock_post.return_value = mock_response
+    def test_publicar(self, mock_publicar):
+        mock_respuesta = MagicMock()
+        mock_respuesta.status_code = 201
+        mock_publicar.return_value = mock_respuesta
 
-        response = post("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
-        self.assertEqual(response.status_code, 201)
+        respuesta = publicar("https://jsonplaceholder.typicode.com/posts", data={"key": "value"})
+        self.assertEqual(respuesta.status_code, 201)
 
     @patch('requests.put')
-    def test_put(self, mock_put):
-        mock_response = MagicMock()
-        mock_response.status_code = 200
-        mock_put.return_value = mock_response
+    def test_poner(self, mock_poner):
+        mock_respuesta = MagicMock()
+        mock_respuesta.status_code = 200
+        mock_poner.return_value = mock_respuesta
 
-        response = put("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
-        self.assertEqual(response.status_code, 200)
+        respuesta = poner("https://jsonplaceholder.typicode.com/posts/1", data={"key": "value"})
+        self.assertEqual(respuesta.status_code, 200)
 
     @patch('requests.delete')
-    def test_delete(self, mock_delete):
-        mock_response = MagicMock()
-        mock_response.status_code = 204
-        mock_delete.return_value = mock_response
+    def test_eliminar(self, mock_eliminar):
+        mock_respuesta = MagicMock()
+        mock_respuesta.status_code = 204
+        mock_eliminar.return_value = mock_respuesta
 
-        response = delete("https://jsonplaceholder.typicode.com/posts/1")
-        self.assertEqual(response.status_code, 204)
+        respuesta = eliminar("https://jsonplaceholder.typicode.com/posts/1")
+        self.assertEqual(respuesta.status_code, 204)
 
     @patch('requests.get')
-    def test_get_with_path_params(self, mock_get):
-        mock_response = MagicMock()
-        mock_response.status_code = 200
-        mock_response.content = b'{"key": "value"}'
-        mock_get.return_value = mock_response
+    def test_obtener_con_parametros_de_ruta(self, mock_obtener):
+        mock_respuesta = MagicMock()
+        mock_respuesta.status_code = 200
+        mock_respuesta.content = b'{"key": "value"}'
+        mock_obtener.return_value = mock_respuesta
 
-        response = get_with_path_params("https://jsonplaceholder.typicode.com/posts", ["1"])
-        self.assertIsNotNone(response)
-        self.assertEqual(response.status_code, 200)
+        respuesta = obtener_con_parametros_de_ruta("https://jsonplaceholder.typicode.com/posts", ["1"])
+        self.assertIsNotNone(respuesta)
+        self.assertEqual(respuesta.status_code, 200)
 
 class TestQueryParams(unittest.TestCase):
 
-    def test_serialize_params(self):
-        params = {
-            "key1": "value1",
-            "key2": "value2",
-            "key3": "value3"
+    def test_serializar_parametros(self):
+        parametros = {
+            "clave1": "valor1",
+            "clave2": "valor2",
+            "clave3": "valor3"
         }
-        result = serialize_params(params)
-        expected = "key1=value1&key2=value2&key3=value3"
-        self.assertEqual(result, expected)
+        resultado = serializar_parametros(parametros)
+        esperado = "clave1=valor1&clave2=valor2&clave3=valor3"
+        self.assertEqual(resultado, esperado)
 
 class TestPathParams(unittest.TestCase):
 
-    def test_construct_url(self):
+    def test_construir_url(self):
         base_url = "https://jsonplaceholder.typicode.com"
-        path_params = ["posts", "1"]
-        result = construct_url(base_url, path_params)
-        expected = "https://jsonplaceholder.typicode.com/posts/1"
-        self.assertEqual(result, expected)
+        parametros_de_ruta = ["posts", "1"]
+        resultado = construir_url(base_url, parametros_de_ruta)
+        esperado = "https://jsonplaceholder.typicode.com/posts/1"
+        self.assertEqual(resultado, esperado)
 
 class TestResponseHandling(unittest.TestCase):
 
     @patch('builtins.open', new_callable=unittest.mock.mock_open)
-    def test_handle_response_zip(self, mock_open):
-        mock_response = MagicMock()
-        mock_response.headers = {'Content-Type': 'application/zip'}
-        mock_response.content = b'PK\x03\x04'  # Mock zip file content
+    def test_manejar_respuesta_zip(self, mock_open):
+        mock_respuesta = MagicMock()
+        mock_respuesta.headers = {'Content-Type': 'application/zip'}
+        mock_respuesta.content = b'PK\x03\x04'  # Contenido simulado de un archivo zip
 
-        handle_response(mock_response, "/fake/path")
+        manejar_respuesta(mock_respuesta, "/fake/path")
         mock_open.assert_called_once_with('temp.zip', 'wb')
 
     @patch('logging.info')
-    def test_handle_response_non_zip(self, mock_logging_info):
-        mock_response = MagicMock()
-        mock_response.headers = {'Content-Type': 'application/json'}
-        mock_response.content = b'{"key": "value"}'
+    def test_manejar_respuesta_no_zip(self, mock_logging_info):
+        mock_respuesta = MagicMock()
+        mock_respuesta.headers = {'Content-Type': 'application/json'}
+        mock_respuesta.content = b'{"key": "value"}'
 
-        handle_response(mock_response, "/fake/path")
-        mock_logging_info.assert_called_with("Response content type: {content_type} - no special handling applied.")
+        manejar_respuesta(mock_respuesta, "/fake/path")
+        mock_logging_info.assert_called_with("Tipo de contenido de respuesta: {content_type} - no se aplicó ningún tratamiento especial.")
 
 if __name__ == "__main__":
     unittest.main()


[≠] Diferencias entre __init___original.py y __init___tipo2.py:
--- __init___original.py
+++ __init___tipo2.py
@@ -1,10 +1,10 @@
-from .api_requests import get, post, put, delete, get_with_path_params
-from .query_params import serialize_params
-from .path_params import construct_url
-from .response_handling import handle_response
+from .api_requests import obtain, transmit, arrange, eliminate, fetch_with_location_descriptors
+from .query_params import format_parameters
+from .path_params import compose_link
+from .response_handling import manage_result
 
 __all__ = [
-    "get", "post", "put", "delete", "get_with_path_params",
-    "serialize_params", "construct_url",
-    "handle_response"
-]
+    "obtain", "transmit", "arrange", "eliminate", "fetch_with_location_descriptors",
+    "format_parameters", "compose_link",
+    "manage_result"
+]


[≠] Diferencias entre __init___original.py y __init___tipo3.py:
--- __init___original.py
+++ __init___tipo3.py
@@ -1,10 +1,10 @@
-from .api_requests import get, post, put, delete, get_with_path_params
-from .query_params import serialize_params
-from .path_params import construct_url
-from .response_handling import handle_response
+from .api_requests import obtener, publicar, poner, eliminar, obtener_con_parametros_ruta
+from .query_params import serializar_parametros
+from .path_params import construir_url
+from .response_handling import manejar_respuesta
 
 __all__ = [
-    "get", "post", "put", "delete", "get_with_path_params",
-    "serialize_params", "construct_url",
-    "handle_response"
-]
+    "obtener", "publicar", "poner", "eliminar", "obtener_con_parametros_ruta",
+    "serializar_parametros", "construir_url",
+    "manejar_respuesta"
+]

